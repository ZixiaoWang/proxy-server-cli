"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get_config_template = function () {
    return "module.exports = {\n    /**\n     * Options for local server\n    */\n    port: 3000,         // set the port for your proxy server,\n    pathMatch: '/',     // matched path will be proxied, others will be ignored\n\n    /** \n     * Options from http-proxy-middleware\n     * Please go to https://github.com/chimurai/http-proxy-middleware#http-proxy-middleware-options for more detailed specification.\n     * Auther:  chimurai\n     * Github repository: https://github.com/chimurai/http-proxy-middleware#http-proxy-middleware-options\n    */\n    // target: null, \t\t    // url string to be parsed with the url module\n    // forward: null, \t\t    // url string to be parsed with the url module\n    // agent: null, \t\t    // object to be passed to http(s).request (see Node's https agent and http agent objects)\n    // ssl: null, \t\t        // object to be passed to https.createServer()\n    ws: true, \t\t            // true/false: if you want to proxy websockets\n    // xfwd: false, \t\t    // true/false, adds x-forward headers\n    // secure: false, \t\t    // true/false, if you want to verify the SSL Certs\n    // toProxy: false, \t\t    // true/false, passes the absolute URL as the path (useful for proxying to proxies)\n    // prependPath: true, \t\t// true/false, Default: true - specify whether you want to prepend the target's path to the proxy path\n    // ignorePath: false, \t\t// true/false, Default: false - specify whether you want to ignore the proxy path of the incoming request (note: you will have to append / manually if required).\n    // localAddress: null, \t\t// Local interface string to bind for outgoing connections\n    changeOrigin: true, \t\t// true/false, Default: false - changes the origin of the host header to the target URL\n    // preserveHeaderKeyCase: false, \t\t// true/false, Default: false - specify whether you want to keep letter case of response header key\n    // auth: null, \t\t        // Basic authentication i.e. 'user:password' to compute an Authorization header.\n    // hostRewrite: null, \t\t// rewrites the location hostname on (301/302/307/308) redirects.\n    // autoRewrite: null, \t\t// rewrites the location host/port on (301/302/307/308) redirects based on requested host/port. Default: false.\n    // protocolRewrite: null, \t\t    // rewrites the location protocol on (301/302/307/308) redirects to 'http' or 'https'. Default: null.\n    // cookieDomainRewrite: null, \t\t// rewrites domain of set-cookie headers.\n    // cookiePathRewrite: null, \t\t// rewrites path of set-cookie headers.\n    // headers: null, \t\t    // object, adds request headers. (Example: {host:'www.example.org'})\n    // proxyTimeout: null, \t\t// timeout (in millis) when proxy receives no response from target\n    // timeout: null, \t\t    // timeout (in millis) for incoming requests\n    // followRedirects: false, \t\t    // true/false, Default: false - specify whether you want to follow redirects\n    // selfHandleResponse: false, \t\t// true/false, if set to true, none of the webOutgoing passes are called and it's your responsibility to appropriately return the response by listening and acting on the proxyRes event\n    // buffer: null, \t\t            // stream of data to send as the request body. Maybe you have some middleware that consumes the request stream before proxying it on e.g. If you read the body of a request into a field called 'req.rawbody' you could restream this field in the buffer \n}";
};
